Real-time Timer Synchronization Flow
The Complete Flow Explained
1. Initial Setup
Admin creates a room:
Admin → POST /api/rooms → Server creates room with shareToken → Returns room data
Admin creates timers:
Admin → POST /api/rooms/123/timers → Server creates timer → Timer stored in DB
Viewers join via shared link:
Viewer → Opens link with shareToken → Vue.js connects to Socket.IO → Joins room
2. Real-time Connection Architecture
┌─────────────┐    Socket.IO     ┌──────────────┐    Socket.IO     ┌─────────────┐
│    Admin    │◄────────────────►│    Server    │◄────────────────►│   Viewer    │
│   (Owner)   │                  │              │                  │ (Shared Link)│
└─────────────┘                  └──────────────┘                  └─────────────┘
       │                                │                                 │
       │                                │                                 │
   Controls timers              Validates & broadcasts              Receives updates
   (start/stop/reset)            to all room members                and syncs UI
3. Step-by-Step Timer Control Flow
When Admin Starts a Timer:

Admin Action (Frontend):

javascript   // Admin clicks "Start Timer" button
   socket.emit('timer-action', {
     timerId: 'timer-uuid-123',
     action: 'start'
   });

Server Processing:

javascript   socket.on('timer-action', async (data) => {
     // 1. Validate permission (is user admin of this room?)
     const timer = await timerService.findById(data.timerId);
     const room = await roomService.findById(timer.roomId);
     
     if (socket.userId !== room.ownerId) {
       socket.emit('error', { message: 'Unauthorized' });
       return;
     }
     
     // 2. Update timer in database
     const updatedTimer = await timerService.updateTimerState(data.timerId, 'start');
     /*
       Database now has:
       - startTimestamp: 2024-01-15T10:30:00Z (now)
       - endTimestamp: 2024-01-15T10:40:00Z (now + 10 minutes)
       - isActive: true
     */
     
     // 3. Broadcast to ALL users in the room (admin + viewers)
     io.to(`room:${timer.roomId}`).emit('timer-update', updatedTimer);
   });

All Clients Receive Update:

javascript   // Both admin and viewers receive this
   socket.on('timer-update', (updatedTimer) => {
     // Update local state
     updateTimerInStore(updatedTimer);
     
     // Start local countdown calculation
     if (updatedTimer.isActive) {
       startLocalCountdown(updatedTimer);
     }
   });
When Viewer Sees the Timer Start:
javascriptfunction startLocalCountdown(timer) {
  const interval = setInterval(() => {
    const now = new Date();
    const endTime = new Date(timer.endTimestamp);
    const remainingMs = endTime.getTime() - now.getTime();
    
    if (remainingMs <= 0) {
      // Timer finished
      displayTime = "00:00";
      clearInterval(interval);
      // Optionally emit timer-finished event
    } else {
      // Calculate and display remaining time
      const minutes = Math.floor(remainingMs / 60000);
      const seconds = Math.floor((remainingMs % 60000) / 1000);
      displayTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
  }, 100); // Update every 100ms for smooth countdown
}
4. Permission System
Admin Permissions (Room Owner):
javascript// Server-side permission check
async function validateTimerAction(socket, timerId, action) {
  const timer = await prisma.timer.findUnique({
    where: { id: timerId },
    include: { room: true }
  });
  
  if (!timer) {
    throw new Error('Timer not found');
  }
  
  // Only room owner can control timers
  if (socket.userId !== timer.room.ownerId) {
    throw new Error('Unauthorized: Only room owner can control timers');
  }
  
  return timer;
}
Viewer Permissions (Shared Link Users):

Can only receive timer updates
Cannot send timer control actions
Can join/leave rooms
Can see user count

5. Frontend Implementation Examples
Admin Interface (Vue.js):
vue<template>
  <div class="timer-controls">
    <div v-for="timer in timers" :key="timer.id" class="timer-card">
      <h3>{{ timer.title }}</h3>
      <div class="countdown">{{ getDisplayTime(timer) }}</div>
      
      <!-- Only show controls if user is admin -->
      <div v-if="isAdmin" class="controls">
        <button @click="startTimer(timer.id)" :disabled="timer.isActive">
          Start
        </button>
        <button @click="pauseTimer(timer.id)" :disabled="!timer.isActive">
          Pause
        </button>
        <button @click="resetTimer(timer.id)">
          Reset
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { io } from 'socket.io-client';

const socket = io('http://localhost:3000');
const timers = ref([]);
const isAdmin = ref(false);

// Admin actions
function startTimer(timerId) {
  socket.emit('timer-action', {
    timerId,
    action: 'start'
  });
}

// Receive updates from server
socket.on('timer-update', (updatedTimer) => {
  const index = timers.value.findIndex(t => t.id === updatedTimer.id);
  if (index !== -1) {
    timers.value[index] = updatedTimer;
  }
});
</script>
Viewer Interface (Shared Link):
vue<template>
  <div class="viewer-mode">
    <h2>{{ roomName }} - Live Timers</h2>
    <div class="users-online">{{ userCount }} viewers online</div>
    
    <div v-for="timer in timers" :key="timer.id" class="timer-display">
      <h3>{{ timer.title }}</h3>
      <div class="countdown" :class="{ active: timer.isActive }">
        {{ getDisplayTime(timer) }}
      </div>
      <div class="status">
        {{ timer.isActive ? 'Running' : 'Paused' }}
      </div>
    </div>
  </div>
</template>

<script setup>
// Same socket listening logic, but no control buttons
// Users automatically get updates when admin changes timers
</script>
6. Key Synchronization Points
Why This Works Perfectly:

Single Source of Truth: Database stores the authoritative timer state
Instant Propagation: Socket.IO broadcasts changes to all connected clients immediately
Client-Side Calculation: Each client calculates remaining time locally using timestamps
Automatic Sync: New users joining get current state immediately via room-state event
No Drift: Using timestamps instead of intervals prevents time drift between clients

Real-World Scenario:
10:30:00 - Admin starts 10-minute timer
         - Server sets endTimestamp to 10:40:00
         - All viewers immediately see timer start counting down

10:32:15 - New viewer joins room
         - Gets current timer state (endTimestamp: 10:40:00)
         - Automatically calculates 7:45 remaining
         - Perfectly synced with everyone else

10:35:30 - Admin pauses timer
         - Server updates timer.isActive = false
         - All viewers immediately see timer pause at 4:30 remaining
This architecture ensures that no matter when someone joins the room or what happens with network connectivity, everyone sees the same timer state because it's all calculated from the same timestamps stored on the server.